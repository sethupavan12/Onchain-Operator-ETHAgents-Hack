import os
import requests
from openai import OpenAI
from cdp import Wallet
from typing import Optional
from dotenv import load_dotenv
from cdp_langchain.utils import CdpAgentkitWrapper
import json
import io

load_dotenv()

# Configure a file to persist the agent's CDP MPC Wallet Data.
wallet_data_file = "wallet_data.txt"

def initialize_wallet():
    """Initialize the wallet with CDP Agentkit."""
    wallet_data = None
    if os.path.exists(wallet_data_file):
        with open(wallet_data_file) as f:
            wallet_data = f.read()

    # Configure CDP Agentkit Langchain Extension.
    values = {}
    if wallet_data is not None:
        # If there is a persisted agentic wallet, load it and pass to the CDP Agentkit Wrapper.
        values = {"cdp_wallet_data": wallet_data}

    agentkit = CdpAgentkitWrapper(**values)

    # Persist the agent's CDP MPC Wallet Data.
    wallet_data = agentkit.export_wallet()
    with open(wallet_data_file, "w") as f:
        f.write(wallet_data)

    return agentkit.wallet

def get_openai_client() -> OpenAI:
    """Get OpenAI client instance."""
    return OpenAI()

def generate_dalle_image(prompt: str, client: OpenAI | None = None) -> str:
    """Generate an image using DALL-E-3."""
    if client is None:
        client = get_openai_client()
    try:
        response = client.images.generate(
            model="dall-e-3",
            prompt=prompt,
            size="1024x1024",
            quality="standard",
            n=1,
        )
        return response.data[0].url
    except Exception as e:
        raise Exception(f"Error generating DALL-E image: {e}") from e

def upload_to_ipfs(image_url: str) -> tuple[str, str]:
    """Upload an image to IPFS via Pinata."""
    pinata_jwt = os.getenv("PINATA_JWT")
    if not pinata_jwt:
        raise Exception("PINATA_JWT environment variable not found")
    try:
        # Download image from DALL-E
        response = requests.get(image_url)
        response.raise_for_status()
        image_data = response.content

        # Prepare for Pinata upload
        files = {
            'file': image_data
        }
        headers = {
            'Authorization': f'Bearer {pinata_jwt}'
        }

        # Upload to Pinata
        pinata_response = requests.post(
            'https://api.pinata.cloud/pinning/pinFileToIPFS',
            files=files,
            headers=headers
        )
        pinata_response.raise_for_status()
        ipfs_hash = pinata_response.json()['IpfsHash']
        ipfs_url = f"ipfs://{ipfs_hash}"
        gateway_url = f"https://gateway.pinata.cloud/ipfs/{ipfs_hash}"
        return ipfs_url, gateway_url
    except Exception as e:
        raise Exception(f"Error uploading to IPFS: {e}") from e

def create_and_upload_metadata(prompt: str, image_ipfs_url: str) -> str:
    """Create and upload NFT metadata to IPFS."""
    pinata_jwt = os.getenv("PINATA_JWT")
    if not pinata_jwt:
        raise Exception("PINATA_JWT environment variable not found")

    metadata = {
        "name": "DALL-E Generated NFT",
        "description": f"This NFT was generated by DALL-E using the prompt: {prompt}",
        "image": image_ipfs_url,
        "attributes": [
            {
                "trait_type": "Generator",
                "value": "DALL-E"
            },
            {
                "trait_type": "Prompt",
                "value": prompt
            }
        ]
    }

    # Convert metadata JSON into a bytes stream
    json_str = json.dumps(metadata)
    json_bytes = io.BytesIO(json_str.encode("utf-8"))

    # Build the multipart form-data parts
    files = {
        "file": ("0", json_bytes, "application/json"),  # File name "0" is crucial
        "pinataMetadata": (None, json.dumps({
            "name": f"DALL-E NFT Metadata"
        }), "application/json"),
        "pinataOptions": (None, json.dumps({
            "cidVersion": 1,
            "wrapWithDirectory": True,
        }), "application/json")
    }

    url = "https://api.pinata.cloud/pinning/pinFileToIPFS"
    headers = {
        "Authorization": f"Bearer {pinata_jwt}"
    }

    try:
        # Upload the file and related metadata/options to Pinata
        response = requests.post(url, files=files, headers=headers)
        response.raise_for_status()

        # Parse Pinata response
        pinata_data = response.json()
        ipfs_hash = pinata_data.get("IpfsHash")
        
        # Return the IPFS URL with /0 to access the file in the wrapped directory
        return f"ipfs://{ipfs_hash}/0"
    except Exception as e:
        raise Exception(f"Error uploading metadata to IPFS: {e}") from e

def dalle_nft(
    wallet: Wallet,
    prompt: str,
    destination: str,
    contract_address: Optional[str] = None,
    collection_name: Optional[str] = None,
    collection_symbol: Optional[str] = None,
) -> str:
    """Generate DALL-E image and mint it as NFT.

    Args:
        wallet (Wallet): The wallet to deploy/mint from
        prompt (str): Text prompt for DALL-E image generation
        destination (str): Destination address to mint the NFT to
        contract_address (str | None): Optional existing NFT contract address
        collection_name (str | None): Required if contract_address not provided: Name of the NFT collection
        collection_symbol (str | None): Required if contract_address not provided: Symbol of the NFT collection

    Returns:
        str: A message containing the operation details

    """
    # Check for missing collection info at start
    if not contract_address and (not collection_name or not collection_symbol):
        raise ValueError("collection_name and collection_symbol required when contract_address not provided")

    try:
        print("üé® Generating image with DALL-E...")
        image_url = generate_dalle_image(prompt)

        print("üì§ Uploading image to IPFS...")
        ipfs_url, gateway_url = upload_to_ipfs(image_url)

        print("üìù Creating NFT metadata...")
        metadata_uri = create_and_upload_metadata(prompt, ipfs_url)
        base_uri = metadata_uri.rsplit('/', 1)[0] + '/'

        if not contract_address:
            print("üìù Deploying new NFT contract...")
            deploy_result = wallet.deploy_nft(
                name=collection_name,
                symbol=collection_symbol,
                base_uri=base_uri
            ).wait()
            contract_address = deploy_result.contract_address
            deploy_tx = f"Deploy Transaction: {deploy_result.transaction.transaction_link}\n"
        else:
            deploy_tx = ""

        print("üéØ Minting NFT...")
        mint_args = {"to": destination, "quantity": "1"}
        mint_result = wallet.invoke_contract(
            contract_address=contract_address,
            method="mint",
            args=mint_args
        ).wait()

        print("‚ú® Success! NFT minted!")
        
        # Add OpenSea link
        opensea_url = f"https://testnets.opensea.io/assets/base_sepolia/{contract_address}/0"
        
        return (
            f"Successfully created and minted DALL-E NFT!\n"
            f"Contract Address: {contract_address}\n"
            f"DALL-E Image URL: {image_url}\n"
            f"IPFS Gateway URL: {gateway_url}\n"
            f"Metadata URI: {metadata_uri}\n"
            f"Mint Transaction: {mint_result.transaction.transaction_link}\n"
            f"{deploy_tx}"
            f"View on OpenSea: {opensea_url}\n"
        )
    except Exception as e:
        if isinstance(e, ValueError):
            raise
        return f"Error in DALL-E NFT process: {e}"

if __name__ == "__main__":
    wallet = initialize_wallet()
    result = dalle_nft(
        wallet=wallet,
        prompt='A majestic dragon soaring through a cyberpunk city at night, with neon lights reflecting off its scales',
        destination=wallet.default_address.address_id,
        collection_name='CyberDragons',
        collection_symbol='CDRG'
    )
    print(result)
